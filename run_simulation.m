function run_simulation(config, vehicleProperties)

% DEFINE TIME LIMIT AND NUMBER OF ITERATIONS FOR THE SIMULATIONS

TIME_LIMIT = config.TIME_LIMIT;
MAX_ITER = config.MAX_ITER;
DELTA = config.DELTA;
MAX_NUM_BLOCKAGE = config.MAX_NUM_BLOCKAGE;

% COMPUTE RSU COVERAGE AREA
temp = sqrt(config.LOSrange^2-(config.heightRSU-config.heightAntenna)^2);
temp = sqrt(temp^2-((config.CVlane-1/2)*config.laneWidth)^2);
Rcov = temp*2; % Horizontal LoS coverage distance

% COMPUTE INTER-RSU DISTANCES
dBs = Rcov/config.numRSU;

timeFractionOnV2V_vec = zeros(MAX_ITER,1);
timeFractionOnV2I_vec = zeros(MAX_ITER,1);
blockageCount_vec = zeros(MAX_ITER,1);
losCount_vec = zeros(MAX_ITER,1);

blockageDurationMat = zeros(MAX_ITER,MAX_NUM_BLOCKAGE);
losDurationMat = zeros(MAX_ITER,MAX_NUM_BLOCKAGE);

for iter = 1:MAX_ITER
    
    % GENERATE CVS AND RSUS
    locCV = 4*config.LOSrange+100; % initial location (on x-axis) of the reference CV
    locRSU = 0:dBs:(locCV+TIME_LIMIT*config.CVspeed_ms+4*Rcov);
    
    % INITIALIZE VEHICLES    
    avgVehicleLength = sum(vehicleProperties.length .* vehicleProperties.probability) + 1/config.s_average; % average distance generated by one vehicle
    maxDistanceCovered = (config.CVspeed_ms-max(vehicleProperties.speed_ms)) * TIME_LIMIT + locCV; % distance difference covered by the CV within TIME_LIMIT
    numVehiclesPerLane = ceil(maxDistanceCovered*3/avgVehicleLength);
    vehicles = generate_vehicles(config, vehicleProperties, numVehiclesPerLane);
    
    time = 0;
    time_on_v2i = 0;
    time_on_v2v = 0;
    v2v_off_time = 0;
    v2v_on_time = 0;
    blockageDuration = 0;
    losDuration = 0;
    blockageCount = 0;
    losCount = 0;
    
    countV2Vfound = 0;
    countV2VnotFound = 0;
    
    % START SIMULATION
    while time < TIME_LIMIT
        time = time + DELTA;
        
        % MOVE ALL VEHICLES
        locCV = locCV + config.CVspeed_ms*DELTA; % move CV
        for k = 1:length(vehicles)
            vehicles{k}.startPositions = vehicles{k}.startPositions + vehicles{k}.speed .* DELTA;
            vehicles{k}.endPositions = vehicles{k}.endPositions + vehicles{k}.speed .* DELTA;
            vehicles{k}.antennaPositions = vehicles{k}.antennaPositions + vehicles{k}.speed .* DELTA;
        end
        
        output = check_V2I_connection(vehicles, config, locRSU, locCV, config.CVlane); % first, check if connected to an RSU via V2I link
        if output == 1
            state = 1;
            time_on_v2i = time_on_v2i + DELTA;
        else % check V2V links
            if sum(vehicleProperties.commProbability)==0 % if no vehicles communicate
                state = 0;
                isV2Vfound = 0;
            else
                [state, isV2Vfound] = check_VehicularRelay_connection_v3(vehicles, config, vehicleProperties, locCV, locRSU);
            end
            if(isV2Vfound)
                countV2Vfound = countV2Vfound + 1;
            else
                countV2VnotFound = countV2VnotFound + 1;
            end
            if state == 1
                time_on_v2v = time_on_v2v + DELTA;
                v2v_on_time = v2v_on_time + 1;
            else
                v2v_off_time = v2v_off_time + 1;
            end
        end
        
        if time == DELTA % if the first iteration, record the state and pre_state
            pre_state = state;
        else
            if pre_state == 0 % if previously blocked
                blockageDuration = blockageDuration + DELTA;
                if state == 1 % end of blockage
                    blockageCount = blockageCount + 1;
                    blockageDurationMat(iter,blockageCount) = blockageDuration;
                    blockageDuration = 0;
                    if(blockageCount == MAX_NUM_BLOCKAGE)
                        break;
                    end
                end
            else % if previously LOS
                losDuration = losDuration + DELTA;
                if state == 0 % end of LOS
                    losCount = losCount + 1;
                    losDurationMat(iter,losCount) = losDuration;
                    losDuration = 0;
                end
            end
        end
        pre_state = state;
        if time == TIME_LIMIT % if the last iteration, check LOS or blocked
            if state == 1 % if the last state is LOS
                losCount = losCount + 1;
                losDurationMat(iter,losCount) = losDuration;
            else % if the last state is blockage
                blockageCount = blockageCount + 1;
                blockageDurationMat(iter,blockageCount) = blockageDuration;
            end
        end
    end
    
    timeFractionOnV2V_vec(iter) = time_on_v2v/time;
    timeFractionOnV2I_vec(iter) = time_on_v2i/time;
    blockageCount_vec(iter) = blockageCount;
    losCount_vec(iter) = losCount;
end

P_b = sum(sum(blockageDurationMat))/(sum(sum(blockageDurationMat))+sum(sum(losDurationMat)));
x = reshape(blockageDurationMat,1,size(blockageDurationMat,1)*size(blockageDurationMat,2));
x = x(x>0);
T_b = mean(x);

textToSave = ['./V2I_data/v2i_dAvg',num2str(1/config.s_average),'_Rlos',num2str(config.LOSrange),'_speed',num2str(vehicleProperties.speed(1)),'_commProb',num2str(vehicleProperties.commProbability(1)),'_NR',num2str(config.numRSU),'_hR',num2str(config.heightRSU),'_TL',num2str(log10(TIME_LIMIT)),'.mat'];
save(textToSave,'blockageDurationMat','losDurationMat','blockageCount_vec','losCount_vec','timeFractionOnV2V_vec','timeFractionOnV2I_vec','P_b','T_b','TIME_LIMIT','config','vehicleProperties')